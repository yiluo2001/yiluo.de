<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2048 Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  :root {
    --bg: #ffffff;       /* White background */

    --board-bg: #d7d7d7;
    --cell-bg: #e8e8e8;

    /* tile shades */
    --tile-2: #e6e6e6;
    --tile-4: #dcdcdc;
    --tile-8: #c8c8c8;
    --tile-16: #b4b4b4;
    --tile-32: #a0a0a0;
    --tile-64: #8c8c8c;
    --tile-128: #787878;
    --tile-256: #646464;
    --tile-512: #505050;
    --tile-1024: #3c3c3c;
    --tile-2048: #1f1f1f;
    --tile-big: #000000;

    --font-main: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    background: var(--bg);
    font-family: var(--font-main);
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    color: #3c3c3c;
  }

  .wrapper {
    width: 100%;
    max-width: 480px;
    padding: 16px;
  }

  .heading {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }

  .title {
    font-size: 48px;
    font-weight: 700;
    color: #1a1a1a;
  }

  .scores {
    display: flex;
    gap: 8px;
  }

  .score-box {
    background: #d0d0d0;
    color: #000;
    padding: 8px 12px;
    border-radius: 4px;
    text-align: center;
    min-width: 72px;
    font-weight: 600;
  }

  .grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
  }

  button {
    cursor: pointer;
    background: #555;
    color: #fff;
    border-radius: 4px;
    border: none;
    padding: 8px 16px;
    font-weight: 600;
    transition: 0.2s;
  }

  button:hover {
    background: #7a7a7a;
    transform: translateY(-1px);
  }

  .game-container {
    position: relative;
    background: var(--board-bg);
    border-radius: 6px;
    padding: 10px;
    width: 100%;
    max-width: 480px;
    margin: auto;
  }

  .cell {
    background: var(--cell-bg);
    border-radius: 3px;
    padding-bottom: 100%;
    position: relative;
  }

  .cell-inner {
    position: absolute;
    inset: 0;
    display: flex;
    align-items:center;
    justify-content: center;
    font-size: 32px;
    font-weight: 700;
    border-radius: 3px;
    color: #000;
    transition: transform .1s;
  }

  .tile-0 { background: var(--cell-bg); color: transparent; }
  .tile-2  { background: var(--tile-2); }
  .tile-4  { background: var(--tile-4); }
  .tile-8  { background: var(--tile-8); color: #000; }
  .tile-16 { background: var(--tile-16); color: #000; }
  .tile-32 { background: var(--tile-32); color: #fff; }
  .tile-64 { background: var(--tile-64); color: #fff; }
  .tile-128, .tile-256, .tile-512, .tile-1024, .tile-2048, .tile-super {
    color: #fff;
  }
  .tile-128 { background: var(--tile-128); font-size: 28px; }
  .tile-256 { background: var(--tile-256); font-size: 28px; }
  .tile-512 { background: var(--tile-512); font-size: 26px; }
  .tile-1024 { background: var(--tile-1024); font-size: 24px; }
  .tile-2048 { background: var(--tile-2048); font-size: 22px; }
  .tile-super { background: var(--tile-big); font-size: 20px; }

  .game-message {
    position: absolute;
    inset: 0;
    background: rgba(255,255,255,0.75);
    font-size: 28px;
    font-weight: 700;
    display: flex;
    flex-direction: column;
    justify-content: center;
    text-align: center;
    border-radius: 6px;
    color: #333;
    opacity: 0;
    pointer-events:none;
    transition: .2s;
  }

  .game-message.visible {
    opacity:1;
    pointer-events:auto;
  }

  .mobile-hint {
    font-size: 12px;
    color: #555;
    margin-top: 8px;
  }
</style>

</head>
<body>
  <div class="wrapper">
    <div class="heading">
      <div class="title">2048</div>
      <div class="scores">
        <div class="score-box">
          <div class="label">Score</div>
          <div class="value" id="score">0</div>
        </div>
        <div class="score-box">
          <div class="label">Best</div>
          <div class="value" id="best-score">0</div>
        </div>
      </div>
    </div>

    <div class="controls">
      <p>Join the numbers to reach <strong>2048</strong>! Use arrow keys or WASD.</p>
      <button id="new-game-btn">New Game</button>
    </div>

    <div class="game-container" id="game-container">
      <div class="grid" id="grid">
        <!-- 16 cells -->
      </div>
      <div class="game-message" id="game-message">
        <div id="message-text"></div>
        <button id="keep-playing-btn">Keep Going</button>
        <button id="restart-btn" style="margin-left:8px;">Restart</button>
      </div>
    </div>

    <div class="mobile-hint">On touch devices, swipe to move tiles.</div>
  </div>

  <script>
    // Game constants
    const SIZE = 4;
    const START_TILES = 2;

    let grid = [];
    let score = 0;
    let bestScore = 0;
    let gameWon = false;
    let gameOver = false;

    const gridElement = document.getElementById('grid');
    const scoreElement = document.getElementById('score');
    const bestScoreElement = document.getElementById('best-score');
    const newGameBtn = document.getElementById('new-game-btn');
    const gameMessage = document.getElementById('game-message');
    const messageText = document.getElementById('message-text');
    const keepPlayingBtn = document.getElementById('keep-playing-btn');
    const restartBtn = document.getElementById('restart-btn');
    const gameContainer = document.getElementById('game-container');

    // Initialize grid DOM
    function buildGridDOM() {
      gridElement.innerHTML = '';
      for (let i = 0; i < SIZE * SIZE; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        const inner = document.createElement('div');
        inner.className = 'cell-inner tile-0';
        inner.dataset.index = i;
        cell.appendChild(inner);
        gridElement.appendChild(cell);
      }
    }

    // Initialize a new game
    function newGame() {
      grid = [];
      for (let row = 0; row < SIZE; row++) {
        const line = [];
        for (let col = 0; col < SIZE; col++) {
          line.push(0);
        }
        grid.push(line);
      }
      score = 0;
      gameWon = false;
      gameOver = false;
      hideMessage();
      updateScore();
      for (let i = 0; i < START_TILES; i++) {
        addRandomTile();
      }
      renderGrid(true);
    }

    function loadBestScore() {
      const stored = localStorage.getItem('bestScore2048');
      if (stored) {
        bestScore = parseInt(stored, 10) || 0;
      }
      bestScoreElement.textContent = bestScore;
    }

    function saveBestScore() {
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('bestScore2048', String(bestScore));
        bestScoreElement.textContent = bestScore;
      }
    }

    function updateScore() {
      scoreElement.textContent = score;
      saveBestScore();
    }

    function addRandomTile() {
      const empty = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (grid[r][c] === 0) {
            empty.push({ r, c });
          }
        }
      }
      if (empty.length === 0) return false;
      const idx = Math.floor(Math.random() * empty.length);
      const cell = empty[idx];
      const value = Math.random() < 0.9 ? 2 : 4;
      grid[cell.r][cell.c] = value;
      return { r: cell.r, c: cell.c };
    }

    function renderGrid(spawnAnimation) {
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const index = r * SIZE + c;
          const inner = gridElement.querySelector('.cell-inner[data-index="' + index + '"]');
          const value = grid[r][c];
          inner.textContent = value === 0 ? '' : value;
          inner.className = 'cell-inner ' + getTileClass(value);
        }
      }

      // Optional spawn animation handled by caller (to avoid layout recalcs)
      if (spawnAnimation && spawnAnimation.r !== undefined) {
        const { r, c } = spawnAnimation;
        const index = r * SIZE + c;
        const inner = gridElement.querySelector('.cell-inner[data-index="' + index + '"]');
        inner.classList.add('spawn');
        setTimeout(() => inner.classList.remove('spawn'), 160);
      }
    }

    function getTileClass(value) {
      if (value === 0) return 'tile-0';
      if (value <= 2048) {
        return 'tile-' + value;
      }
      return 'tile-super';
    }

    // Movement helpers
    function moveLeftRow(row) {
      const original = row.slice();
      let filtered = row.filter(v => v !== 0);

      for (let i = 0; i < filtered.length - 1; i++) {
        if (filtered[i] === filtered[i + 1]) {
          filtered[i] *= 2;
          score += filtered[i];
          filtered[i + 1] = 0;
          i++;
        }
      }

      filtered = filtered.filter(v => v !== 0);
      while (filtered.length < SIZE) {
        filtered.push(0);
      }

      const moved = !arraysEqual(original, filtered);
      return { row: filtered, moved };
    }

    function transpose(matrix) {
      const result = [];
      for (let c = 0; c < SIZE; c++) {
        const col = [];
        for (let r = 0; r < SIZE; r++) {
          col.push(matrix[r][c]);
        }
        result.push(col);
      }
      return result;
    }

    function reverseRows(matrix) {
      return matrix.map(row => row.slice().reverse());
    }

    function arraysEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

    function cloneGrid(g) {
      return g.map(row => row.slice());
    }

    function move(direction) {
      if (gameOver || (gameWon && gameMessage.classList.contains('visible'))) return;

      let moved = false;
      let newGrid = cloneGrid(grid);

      if (direction === 'left') {
        for (let r = 0; r < SIZE; r++) {
          const result = moveLeftRow(newGrid[r]);
          newGrid[r] = result.row;
          if (result.moved) moved = true;
        }
      } else if (direction === 'right') {
        for (let r = 0; r < SIZE; r++) {
          const reversed = newGrid[r].slice().reverse();
          const result = moveLeftRow(reversed);
          newGrid[r] = result.row.reverse();
          if (result.moved) moved = true;
        }
      } else if (direction === 'up') {
        newGrid = transpose(newGrid);
        for (let r = 0; r < SIZE; r++) {
          const result = moveLeftRow(newGrid[r]);
          newGrid[r] = result.row;
          if (result.moved) moved = true;
        }
        newGrid = transpose(newGrid);
      } else if (direction === 'down') {
        newGrid = transpose(newGrid);
        for (let r = 0; r < SIZE; r++) {
          const reversed = newGrid[r].slice().reverse();
          const result = moveLeftRow(reversed);
          newGrid[r] = result.row.reverse();
          if (result.moved) moved = true;
        }
        newGrid = transpose(newGrid);
      }

      if (!moved) return;

      grid = newGrid;
      updateScore();

      const spawnPos = addRandomTile() || {};
      renderGrid(spawnPos);

      checkGameState();
    }

    function checkGameState() {
      let has2048 = false;
      let hasEmpty = false;

      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const val = grid[r][c];
          if (val === 2048) {
            has2048 = true;
          }
          if (val === 0) {
            hasEmpty = true;
          }
        }
      }

      if (has2048 && !gameWon) {
        gameWon = true;
        showMessage('You win! ðŸŽ‰');
        return;
      }

      if (hasEmpty) return;

      // Check possible merges (no empty cells)
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const val = grid[r][c];
          if (r < SIZE - 1 && grid[r + 1][c] === val) return;
          if (c < SIZE - 1 && grid[r][c + 1] === val) return;
        }
      }

      gameOver = true;
      showMessage('Game over ðŸ˜¢');
    }

    function showMessage(text) {
      messageText.textContent = text;
      gameMessage.classList.add('visible');
    }

    function hideMessage() {
      gameMessage.classList.remove('visible');
    }

    // Input handling
    function handleKeydown(e) {
      const key = e.key;
      let direction = null;

      if (key === 'ArrowLeft') direction = 'left';
      else if (key === 'ArrowRight') direction = 'right';
      else if (key === 'ArrowUp') direction = 'up';
      else if (key === 'ArrowDown') direction = 'down';
      else if (key === 'a' || key === 'A') direction = 'left';
      else if (key === 'd' || key === 'D') direction = 'right';
      else if (key === 'w' || key === 'W') direction = 'up';
      else if (key === 's' || key === 'S') direction = 'down';

      if (direction) {
        e.preventDefault();
        move(direction);
      }
    }

    // Basic touch swipe support
    let touchStartX = null;
    let touchStartY = null;

    function handleTouchStart(e) {
      if (!e.touches || e.touches.length === 0) return;
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
    }

    function handleTouchEnd(e) {
      if (touchStartX === null || touchStartY === null) return;
      if (!e.changedTouches || e.changedTouches.length === 0) return;

      const t = e.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;

      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      const threshold = 20;

      if (Math.max(absX, absY) > threshold) {
        if (absX > absY) {
          move(dx > 0 ? 'right' : 'left');
        } else {
          move(dy > 0 ? 'down' : 'up');
        }
      }

      touchStartX = null;
      touchStartY = null;
    }

    // Event listeners
    window.addEventListener('keydown', handleKeydown);
    gameContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
    gameContainer.addEventListener('touchend', handleTouchEnd);

    newGameBtn.addEventListener('click', newGame);
    restartBtn.addEventListener('click', newGame);
    keepPlayingBtn.addEventListener('click', () => {
      hideMessage();
    });

    // Init
    buildGridDOM();
    loadBestScore();
    newGame();
  </script>
</body>
</html>
